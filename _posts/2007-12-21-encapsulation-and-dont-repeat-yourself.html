---
layout: post
title: Encapsulation and don't repeat yourself
date: 2007-12-21 22:28:51.000000000 +01:00
type: post
published: true
status: publish
categories: []
tags:
- ruby
- software
meta:
  posterous_6c96d52da40a5d7e34be538822acc826_post_id: '48644480'
  posterous_6c96d52da40a5d7e34be538822acc826_permalink: http://duncan.mac-vicar.com/encapsulation-and-dont-repeat-yourself
  _oembed_31c31969d9ae29880b0b7a28704522b8: "{{unknown}}"
  _oembed_af53d34b53a232362b6aa82f1b654fd9: "{{unknown}}"
  _oembed_bb9b25c8cc9a076c1f6f4b20d2fb6188: "{{unknown}}"
  _oembed_80f8393f85618ce4176e59a6cb089027: "{{unknown}}"
author:
  login: duncan
  email: dmacvicar@gmail.com
  display_name: duncan
  first_name: Duncan
  last_name: Mac-Vicar P.
---
<p>
    Richard Moore [comment][1] on [Access Anxiety][2] explains why Encapsulation is a good thing. I think both are missing the point. Nobody doubts that encapsulation is a good thing, and Michael Feathers tries to present ruby way as a more "relaxed" thing.</p>
<p>&gt;The author was comparing the 'ruby style' of direct access to member variables with the getter/setter pattern common in Java code</p>
<p>So what is the ruby style really?</p>
<p>The annoying thing about java setters is that they are functions. So you either start with them (which is overkill for simple things) or don't use them and then you are lost when you want to add things like Richard showed.</p>
<p>Ruby on the other hand, makes it easy, because you can't expose member variables, but you can very easily create default accessors.</p>
<p>Michael Feathers example is wrong. Usually you start by actually offering a simple default accessor.</p>
<div class="CodeRay">
<div class="code">
<pre>class GlazeObject
  attr_accessor :store, :formatter

  def initialize
    @store = DefaultStore.new
    @formatter = DefaultFormatter.new
  end
end</pre>
</div>
</div>
<p>Now, if you need something more special, like Richard example:</p>
<div class="CodeRay">
<div class="code">
<pre>public void setFormatter(Formatter formatter) {
        this.formatter = formatter;
        this.expensive = doCalculation(formatter);
    }</pre>
</div>
</div>
<p>You can just remove attr_accessor :formatter and add to the class:</p>
<div class="CodeRay">
<div class="code">
<pre>class GlazeObject
  def formatter
    return @formatter
  end

  def formatter=(f)
    @formatter = f;
     @expensive = doCalculation(f);
  end
end</pre>
</div>
</div>
<p>What is the difference? In ruby, for client code consuming this class, you always see obj.formatter for both cases. In java you have to start from the beginning copy-pasting repetitive accessor code if you don't want to start changing obj.formatter to obj.getFormatter() and obj.formater = something to obj.setFormatter(something).</p>
<p>C# has a similar feature, called properties.</p>
<div class="CodeRay">
<div class="code">
<pre>public class Person
{
  private int _age;
  public int age
  {
   get
   {
     return _age;
   }
   set
   {
     _age = value;
   }
  }
}</pre>
</div>
</div>
<p>No matter if we start with a public variable called age, we can move it to setters and getters (which are the providers of encapsulation without having to change the operation mode from variables to functions.</p>
<p> [1]: <a href="http://www.kdedevelopers.org/node/3163">http://www.kdedevelopers.org/node/3163</a><br />
 [2]: <a href="http://beautifulcode.oreillynet.com/2007/12/access_anxiety.php">http://beautifulcode.oreillynet.com/2007/12/access_anxiety.php</a></p>
